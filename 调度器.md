## goroutine和thread区别

> goroutine用户态
>
> thread内核态

- 内存占用

创建一个goroutine内存消耗为2KB。创建一个thread内存消耗为1MB，而且还需要一个被称为“a gurad page”的区域用于和其他thread的栈空间进行隔离

对于Go server来说，对于每一个请求都是新创建一个goroutine来处理，单独的请求。如果对于thread作为并发原语很快程序就会OOM

- 创建和销毁

thread的创建和销毁消耗巨大，因为是和内核级的操作，通常需要线程池来解决。

goroutine是由go runtime 负责管理，创建和销毁的，消耗特别小，是用户级的

- 切换

thread切换，需要保存各种寄存器的值，以便将来进行恢复

goroutine切换只需要保存三个寄存器：program counter，stack pointer and BP

一般：thread切换需要消耗1000-1500纳秒，gouroutine切换需要200ns

## scheduler

1. Go的执行程序由两部分组成：Go program，Runtime即用户程序和运行时

2. 用户程序进行的系统调用都会被Runtime拦截，以此来帮助它进行调度以及垃圾回收相关工作（Runtime维护所有的goroutine，并通过scheduler来进行调度）

### Scheduler底层原理

有三个基础结构来实现goroutine的调度（GPM）

- g：代表一个goroutine，它包含goroutine栈的一些字段，指示当前goroutine的状态，指示当前运行到的指令地址，也就是PC的值
- m：代表内核线程，包含正在运行的goroutine字段
- p：代表一个虚拟的Processor，维护一个处于Runable状态的g队列，m需要获得p才能运行g

还有一个核心结构体 `sched`，它总览全局。

Os scheduler核心思想：

1. resuse thread
2. 限制同时运行（不包含阻塞）的线程数为N，N等于CPU核心数目
3. 线程私有的runqueues，可以从其他线程stealing goroutine来运行，线程阻塞后，可以将runqueues 传递给其他线程

goroutine的三种状态：

| 状态      | 解释                                                         |
| :-------- | ------------------------------------------------------------ |
| Waiting   | 等待状态，goroutine在等待某件事发生。例如等待网络数据、硬盘；调用操作系统API；等待内存同步访问条件ready如：atomic、mutexes |
| Runnable  | 就绪状态只要给我M就能运行                                    |
| Executing | 运行状态。goroutine在M上执行命令                             |

GPM全局示意图：

![image-20210315215511980](image-20210315215511980.png)

## M：N

Go runtime会负责goroutine的生老病死，从创建到销毁一手包办。runtime会在程序启动的时候创建M个线程，之后创建的N的goroutine都会依附在M个线程上执行。



需要了解的知识点：

1. 线程私有变量，TLS技术





